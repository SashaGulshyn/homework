package src.home_work_1;

public class Point2 {
    public static void main(String[] args) {
        int a = 5;
        int b = 2;
        int c = 8;
        int d = 7;
        int e = 20;
        int f = 68;
        int g = 22;
        int h = 68;
        int i = 3;
        int j = 12;
        int k = 6;
        int l = 119;
        boolean T = true;
        boolean F = false;
        System.out.println (a + b / c); //сначала деление, потом сложение = 5.25
        System.out.println((a + b) / c); //сначала действие в скобках, затем деление = 0.875
        System.out.println((a + b++) / c); // я не совсем понимаю, по какой причине b++ сразу не даёт тройку.Тут, видимо, прицип тот же, что из пункта "Важно" из ДЗ по поводу --8. (Idea пишет, что значение не было использовано, по этой причине результат тот же, что и в предыдущем примере = 0)
        System.out.println((a + b++) / --c); //сначала ++, затем сложение, после -- за скобками, затем деление = 1.14285
        System.out.println((a * b >> b++) / --c); //сначала ++, затем умножение, после смещение вправо, затем -- за скобками и деление = (сдвиг десяти на 3 в двоичной системе 1010 >> 3=1. Делим на 8 = 0.125
        System.out.println((a + b > e ? h : g * b >> b++)/ --c); //сначала ++ в скобках, затем умножение и сложение и сдвиг вправо на 3 числа 44 в двоичном виде. (12 > 20 ? 68 : 5). 12>20=false, выражение нормер 3 с числом 5 делим на 7 за скобками = 0.625
        System.out.println((a + b > e ? h >= h : g * b >> b++)/ --c); //то же самое, но добавляется условие больше либо равно, где 68>=68 примет true. Как говорит Idea, делить boolean тип true на --8 не вариант, так что мы видим ошибку в консоли
        System.out.println(k - b > i && j * j <= l); ////сначала умножение, затем вычитание, больше и меньше или равно, закончим логическим операндом. 4 > 3 (true) && 144 <= 199 (false). true&&false = false.
        System.out.println(T && F); //здесь резульат false, согласно таблице на странице 72 из презентации
    }
}